/**
 * @file % !FILENAME %
 *
 * @section desc File description
 *
 * OS data structure generated from application % !CPUNAME %
 * Automatically generated by goil on % !TIMESTAMP %
 * from root OIL file % !OILFILENAME%
 *
 * @section copyright Copyright
 *
 * Trampoline OS
 *
 * Trampoline is copyright (c) IRCCyN 2005-2007
 * Trampoline is protected by the French intellectual property law.
 *
 * This software is distributed under the Lesser GNU Public Licence
 *
 * @section infos File informations
 *
 * $Date$
 * $Rev$
 * $Author$
 * $URL$
 */
%
if OS::RESURRECT then 
%
#include <stdbool.h>
#include <stdint.h>

#include "tpl_os_internal_types.h"
#include "tpl_resurrect_kernel.h"
#include "tpl_os_definitions.h"

#include "tpl_os.h"

%

let listEntry := @[]
foreach resurrect_transition in RESURRECT_TRANSITION do
  let key := resurrect_transition::ENTRY
  let listEntryLength := [listEntry length]
  if listEntryLength == 0 then
     let listEntry[key] := key
  else
   foreach item in listEntry do
     if item == key then
   
    else 
      let listEntry[key] := key
    end if
   end foreach
  end if
end foreach


let listFunc := @[]
foreach resurrect_transition in RESURRECT_TRANSITION do
  if exists resurrect_transition::FUNC then
    foreach item in resurrect_transition::FUNC do
     let key := item::VALUE
     let listFuncLength := [listFunc length]
     if listFuncLength == 0 then
       let listFunc[key] := key
     else
     foreach token in listFunc do
       if token == key then
       
       else
         let listFunc[key] := key
       end if
     end foreach
     end if
    end foreach
  end if
end foreach
foreach item in listFunc do
%
extern void % !item %(void);
%
end foreach


#------------------------------------------------------------------------------*
%
#define APP_COMMON_START_SEC_CODE
#include "tpl_memmap.h"
%
foreach resurrect_transition in RESURRECT_TRANSITION do
 if exists resurrect_transition::FUNC then
  foreach item in listEntry do
   if item == resurrect_transition::ENTRY then
    foreach resurrect_transition_func in resurrect_transition::FUNC
      before
%
FUNC(void, OS_APPL_CODE) % !item% (void){   
%
      do
tab(5) !resurrect_transition_func::VALUE%();
%
      after
tab(5)%TerminateStepResurrect();
}
%

     end foreach
   let listEntry[item] := "NULL"
   end if
  end foreach
 end if
end foreach
%
#define APP_COMMON_STOP_SEC_CODE
#include "tpl_memmap.h"
%
#------------------------------------------------------------------------------*

let listState := @[]
foreach resurrect_state in RESURRECT_STATE do
  let key := resurrect_state::NAME
  let listState[key] := INDEX
end foreach

#------------------------------------------------------------------------------*


%
#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"
%
foreach resurrect_transition in RESURRECT_TRANSITION 
  do
  %
CONST(tpl_step, OS_CONST) step_% !resurrect_transition::NAME% = {
  .energy = % !resurrect_transition::ENERGY%
, .to_state = % !listState[resurrect_transition::TO_STATE]%
, .from_state = % !listState[resurrect_transition::FROM_STATE]%
, .entry_point = % !resurrect_transition::ENTRY%
};
%
end foreach

%
#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"
%
let initial_state
let count_initial := 0

foreach resurrect_state in RESURRECT_STATE do
  if resurrect_state::INITIAL_STATE then
    let initial_state := resurrect_state::NAME
    let count_initial := count_initial+1
    if count_initial > 1 then
     error resurrect_state::INITIAL_STATE : "More than one initial state"
    end if
  end if
  
end foreach

%

/**
 * @internal
 *
 * tpl_kern_resurrect gather informations on the current step and
 * the state
 */
VAR(tpl_kern_resurrect_state, OS_VAR) tpl_kern_resurrect =
{
  NULL,                      /* no elected step   */
  % !listState[initial_state]%,                         /* current state is STATE with INITIAL_STATE = TRUE */
};

#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"
%

foreach resurrect_state in RESURRECT_STATE do
      %
CONSTP2VAR(tpl_step, AUTOMATIC, OS_APPL_DATA) step_from_state_%!resurrect_state::NAME% [%!OS::RESURRECT_S::ENERGY_LEVEL%] = {
%
      let transitionListEnergy := @()
      foreach resurrect_transition in RESURRECT_TRANSITION do
        if resurrect_state::NAME == resurrect_transition::FROM_STATE then
         let transitionListEnergy += resurrect_transition
         end if
      end foreach
      sort transitionListEnergy by ENERGY >
      foreach item in transitionListEnergy do
      %&step_% !item::NAME
      between
      %,
%
      after
      if [transitionListEnergy length] < OS::RESURRECT_S::ENERGY_LEVEL then
       let null_count := OS::RESURRECT_S::ENERGY_LEVEL - [transitionListEnergy length]
       for cnt in null_count
       do
         %
, NULL%
       end for
      end if
      %};
%
      end foreach
end foreach

foreach resurrect_state in RESURRECT_STATE
before
%
CONSTP2CONST(tpl_step_ref, AUTOMATIC, OS_APPL_DATA) tpl_step_state [RESURRECT_STATE_COUNT] = {
%
do
%step_from_state_%!resurrect_state::NAME
between
%,
%
after
%
};
%
end foreach
%
#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"
%
end if

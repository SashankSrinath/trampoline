/**
 * @file % !FILENAME %
 *
 * @section desc File description
 *
 * OS data structure generated from application % !CPUNAME %
 * Automatically generated by goil on % !TIMESTAMP %
 * from root OIL file % !OILFILENAME%
 *
 * @section copyright Copyright
 *
 * Trampoline OS
 *
 * Trampoline is copyright (c) IRCCyN 2005-2007
 * Trampoline is protected by the French intellectual property law.
 *
 * This software is distributed under the Lesser GNU Public Licence
 *
 * @section infos File informations
 *
 * $Date$
 * $Rev$
 * $Author$
 * $URL$
 */
%
if OS::SEQUENCING then 
%
#include <stdbool.h>
#include <stdint.h>

#include "tpl_os_internal_types.h"
#include "tpl_sequence_kernel.h"
#include "tpl_os_definitions.h"

%

#------------------------------------------------------------------------------*
let listTask := @[]
foreach proc in PROCESSES do
  if proc::KIND == "Task" then
   let key := proc::NAME
   let listTask[key] := INDEX
  end if
end foreach

let listState := @[]
foreach state in STATE do
  let key := state::NAME
  let listState[key] := INDEX
end foreach

let listAlarm := @[]
foreach al in ALARM do
  let key := al::NAME
  let listAlarm[key] := INDEX
end foreach


#------------------------------------------------------------------------------*

foreach transition in TRANSITION do
  if exists transition::TASK then
    let task_count := [transition::TASK length]
    foreach task in transition::TASK 
    before 
%
#define OS_START_SEC_CONST_8BIT
#include "tpl_memmap.h"
const uint8 % !transition::NAME%_task[% !task_count%] = {
%
    do
!listTask[task::VALUE]  % /* id of task */%
    between
    %, 
%
    after 
    %
};
#define OS_STOP_SEC_CONST_8BIT
#include "tpl_memmap.h"
%
    end foreach
  end if
  
  if exists transition::ALARM then
   let alarm_count := [transition::ALARM length]
   foreach alarm in transition::ALARM
   before
%
#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
VAR(tpl_sequence_alarm, OS_VAR) % !transition::NAME%_alarm[% !alarm_count%] = {
%
  do
  foreach al in ALARM do
   if alarm::VALUE == al::NAME then
%{%!listAlarm[alarm::VALUE]   %    /* id alarm */
,%!al::ALARMTIME          %    /* alarm time */
,%!al::CYCLETIME          %    /* cycle time */
,%!al::NB_ACTIVATION      %    /* number of activation of alarm */
,%!al::NB_ACTIVATION      %    /* constant to reset number of activation */
}%
   end if 
  end foreach
  between
  %,
%
  after
  %
};

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
%
   end foreach
  end if
end foreach

%
#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
%
foreach transition in TRANSITION 
  do
  %
VAR(tpl_sequence, OS_VAR) sequence_% !transition::NAME% = {
  .energy = % !transition::ENERGY%
, .to_state = % !listState[transition::TO_STATE]%
, .from_state = % !listState[transition::FROM_STATE]%
%
if exists transition::TASK then
%, .nb_task = % ![transition::TASK length]%     
, .seqTaskTab = % !transition::NAME%_task
%
else
%, .nb_task = 0     
, .seqTaskTab = NULL
%
end if
if exists transition::ALARM then
%, .nb_alarm = % ![transition::ALARM length]%
, .seqAlarmTab = % !transition::NAME%_alarm
%
else
%, .nb_alarm = 0
, .seqAlarmTab = NULL
%
end if

let mask := 0
if exists transition::TASK then
foreach task in transition::TASK do
let mask := mask +(1<<listTask[task::VALUE])
end foreach
end if
if exists transition::ALARM then
foreach alarm in transition::ALARM do
let mask := mask +(1<<(listAlarm[alarm::VALUE] + [listTask length]))
end foreach
end if
%, .mask_seq_terminate = %![mask hexString]%
, .vec_seq_terminate = %![mask hexString]%
};
%
end foreach

%
#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
%
let initial_state
let count_initial := 0

foreach state in STATE do
  if state::INITIAL_STATE then
    let initial_state := state::NAME
    let count_initial := count_initial+1
    if count_initial > 1 then
     error state::INITIAL_STATE : "More than one initial state"
    end if
  end if
  
end foreach

%

/**
 * @internal
 *
 * tpl_kern_seq gather informations on the current sequence and
 * the state
 */
VAR(tpl_kern_seq_state, OS_VAR) tpl_kern_seq =
{
  NULL,                      /* no elected sequence   */
  % !listState[initial_state]%,                         /* current state is STATE with INITIAL_STATE = TRUE */
};


#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"
%

foreach state in STATE do
      %
CONSTP2VAR(tpl_sequence, AUTOMATIC, OS_APPL_DATA) sequence_from_state_%!state::NAME% [%!OS::SEQUENCING_S::ENERGY_LEVEL%] = {
%
      let transitionListEnergy := @()
      foreach transition in TRANSITION do
        if state::NAME == transition::FROM_STATE then
         let transitionListEnergy += transition
         end if
      end foreach
      sort transitionListEnergy by ENERGY >
      foreach item in transitionListEnergy do
      %&sequence_% !item::NAME
      between
      %,
%
      after
      if [transitionListEnergy length] < OS::SEQUENCING_S::ENERGY_LEVEL then
       let null_count := OS::SEQUENCING_S::ENERGY_LEVEL - [transitionListEnergy length]
       for cnt in null_count
       do
         %
, NULL%
       end for
      end if
      %};
%
      end foreach
end foreach

foreach state in STATE
before
%
CONSTP2CONST(tpl_sequence_ref, AUTOMATIC, OS_APPL_DATA) tpl_sequence_state [STATE_COUNT] = {
%
do
%sequence_from_state_%!state::NAME
between
%,
%
after
%
};
%
end foreach
%
#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"
%
end if